//----------------------------------------------------------------------------------------------------
//библиотеки
//----------------------------------------------------------------------------------------------------
#include "based.h"
#include "output.h"
#include "sensor.h"
#include "rtc.h"

//----------------------------------------------------------------------------------------------------
//прототипы функций
//----------------------------------------------------------------------------------------------------
void InitAVR(void);//инициализация контроллера

//----------------------------------------------------------------------------------------------------
//глобальные переменные
//----------------------------------------------------------------------------------------------------
volatile uint8_t Digit[4]={0,0,0,0};//текущие отображаемые цифры
volatile uint8_t NewDigit[4]={0,0,0,0};//новые отображаемые цифры
volatile uint8_t ChangeDigitCounter[4]={0,0,0,0};//счётчик перехода от старых к новым цифрам

//----------------------------------------------------------------------------------------------------
//основная функция программы
//----------------------------------------------------------------------------------------------------
int main(void)
{
 InitAVR(); 

 sei();
 uint8_t digit=0; 
 while(1)
 {
  uint8_t hour;
  uint8_t min;
  uint8_t sec;//получить время 
  RTC_GetTime(&hour,&min,&sec);
 
  uint8_t set_digit[4];
  set_digit[0]=min/10;
  set_digit[1]=min%10;
  set_digit[2]=sec/10;
  set_digit[3]=sec%10;
 
  cli();  
  for(uint8_t n=0;n<4;n++)
  {
   if (NewDigit[n]!=set_digit[n]) ChangeDigitCounter[n]=0x1f;
   NewDigit[n]=set_digit[n];
  }
  sei();
  
  _delay_ms(100);
  digit++;
  digit%=10;  
 }
 
 
 


 /* 
 uint8_t digit_array[4]={0,0,0,0};
 while(1)
 {
  int8_t temp;//температура
  int8_t humidity;//влажность
 
  if (SENSOR_GetValue(&temp,&humidity)==true)//меняем показания
  {  
   if (temp<0) OUTPUT_OutputMinus(true);
          else OUTPUT_OutputMinus(false);
   if (temp<0) temp=-temp;
   digit_array[0]=temp/10;
   digit_array[1]=temp%10;
		  
   digit_array[2]=humidity/10;
   digit_array[3]=humidity%10;		  
  }
  else
  {
   digit_array[0]=0;
   digit_array[1]=0;
   digit_array[2]=0;
   digit_array[3]=0;  
  }
  
  OUTPUT_OutputPercent(true);
  OUTPUT_OutputDigit(digit_array); 
  
  _delay_ms(100);   
 }
 cli();
 */
 
 return(0);
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//функции
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//----------------------------------------------------------------------------------------------------
//инициализация контроллера
//----------------------------------------------------------------------------------------------------
void InitAVR(void)
{
 DDRB=0;//весь порт сконфигурирован как вход
 DDRC=0;//весь порт сконфигурирован как вход
 DDRD=0;//весь порт сконфигурирован как вход
 PORTB=0;
 PORTC=0;
 PORTD=0;

 OUTPUT_Init(); 
 SENSOR_Init();
 RTC_Init();
 
 
 //настраиваем таймер T0
 TCCR0=((0<<CS02)|(1<<CS01)|(0<<CS00));//выбран режим деления тактовых импульсов на 8
 TCNT0=0;//начальное значение таймера
 TIMSK=(1<<TOIE0);//прерывание по переполнению таймера (таймер T0 восьмибитный)
}



//----------------------------------------------------------------------------------------------------
//обработчик вектора прерывания таймера T0 (8-ми разрядный таймер) по переполнению
//----------------------------------------------------------------------------------------------------
ISR(TIMER0_OVF_vect)
{
 //таймер вызывается 3906 раз в секунду
 TCNT0=0; 
 //выполняем плавное зажигание/погасанияе цифр с импользованием BAM (binary amplitude modulation)
 static uint8_t counter=0;
 static uint8_t weight=0;
 
 bool change=false;
 uint8_t mask=0;
 
 if (counter>0) counter--;
 if (counter==0)
 {
  mask=(1<<weight);
  counter=mask;
  weight++;
  if (weight==5) weight=0;
  change=true;
 }
 static uint8_t cnt=0;
 cnt++;
 cnt&=63; 
 
 uint8_t digit[4]={Digit[0],Digit[1],Digit[2],Digit[3]};
 static bool new_digit[4]={false,false,false,false};
 
 for(uint8_t n=0;n<4;n++)
 {
  if (ChangeDigitCounter[n]==0) Digit[n]=NewDigit[n];//цифра сменилась
  if (change==true)
  {   
   if (ChangeDigitCounter[n]&mask) new_digit[n]=false;
                              else new_digit[n]=true;
  } 
  if (new_digit[n]==true) digit[n]=NewDigit[n];
  if (cnt==0)
  {
   if (ChangeDigitCounter[n]>0) ChangeDigitCounter[n]--;
  }
 } 
 
 OUTPUT_OutputDigit(digit); 
}
